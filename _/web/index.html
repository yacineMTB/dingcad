<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>DingCAD - Web Viewer</title>
    <!-- Monaco Editor for code editing -->
    <script src="https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs/loader.js" 
            onerror="window.monacoLoadFailed = true; console.warn('Monaco Editor failed to load, will use fallback editor');"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
        }
        
        #canvas-container {
            flex: 1 1 0%;
            position: relative;
            background: #0f0f0f;
            width: 100%;
            min-width: 0;
            min-height: 0;
            margin: 0;
            padding: 0;
            border: none;
            box-sizing: border-box;
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        #canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            margin: 0;
            padding: 0;
            border: none;
            outline: none;
        }
        
        #toolbar {
            background: #2a2a2a;
            padding: 10px 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            border-top: 1px solid #3a3a3a;
            flex-shrink: 0;
        }
        
        #toolbar-buttons {
            display: flex;
            align-items: center;
            justify-content: flex-end;
            gap: 15px;
        }
        
        #code-editor-panel {
            background: #1e1e1e;
            border-top: 1px solid #3a3a3a;
            display: flex !important;
            flex-direction: column;
            transition: height 0.3s ease;
            min-height: 40px;
            height: 40px;
            overflow: hidden;
            margin-left: -20px;
            margin-right: -20px;
            margin-bottom: -10px;
            width: calc(100% + 40px);
        }
        
        #code-editor-panel.expanded {
            height: 400px;
            max-height: 50vh;
        }
        
        #code-editor-panel.minimized {
            height: 40px;
            min-height: 40px;
        }
        
        @media (max-width: 768px) {
            #code-editor-panel {
                height: 35px;
            }
            
            #code-editor-panel.expanded {
                height: 300px;
                max-height: 40vh;
            }
        }
        
        #code-editor-panel.hidden {
            display: none !important;
        }
        
        #editor-header {
            background: #2a2a2a;
            padding: 8px 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            cursor: pointer;
            min-height: 40px;
            flex-shrink: 0;
        }
        
        #code-editor-panel.expanded #editor-header {
            border-bottom: 1px solid #3a3a3a;
        }
        
        #editor-header:hover {
            background: #333;
        }
        
        @media (max-width: 768px) {
            #editor-header {
                padding: 6px 12px;
                min-height: 35px;
            }
        }
        
        #editor-header h3 {
            margin: 0;
            font-size: 14px;
            color: #e0e0e0;
            flex: 1;
        }
        
        @media (max-width: 768px) {
            #editor-header h3 {
                font-size: 12px;
            }
        }
        
        #editor-close {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            padding: 0 10px;
            transition: transform 0.2s ease;
        }
        
        #editor-close:hover {
            color: #fff;
        }
        
        #code-editor-panel.minimized #editor-close {
            transform: rotate(180deg);
        }
        
        #editor-content {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: none;
        }
        
        #code-editor-panel.expanded #editor-content {
            display: block;
        }
        
        
        #library-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 300px;
            height: 100vh;
            background: #1e1e1e;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            z-index: 999;
            transform: translateX(100%);
            transition: transform 0.3s ease;
            box-shadow: -2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        #library-panel.visible {
            transform: translateX(0);
        }
        
        #library-header {
            background: #2a2a2a;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3a3a3a;
        }
        
        #library-header h3 {
            margin: 0;
            font-size: 16px;
            color: #e0e0e0;
        }
        
        #library-close {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            padding: 0 10px;
        }
        
        #library-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .library-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .library-item:hover {
            background: #3a3a3a;
        }
        
        .library-item.selected {
            background: #1a3a2a;
            border-color: #2a5a3a;
        }
        
        .library-item.selected:hover {
            background: #2a4a3a;
        }
        
        .library-item-name {
            font-weight: 600;
            color: #e0e0e0;
            margin-bottom: 4px;
        }
        
        .library-item-desc {
            font-size: 12px;
            color: #a0a0a0;
        }
        
        .library-folder-header {
            padding: 8px 12px;
            margin-top: 12px;
            margin-bottom: 4px;
            font-size: 12px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid #3a3a3a;
        }
        
        .library-folder-header:first-child {
            margin-top: 0;
        }
        
        #library-toggle {
            font-size: 14px;
            padding: 8px 16px;
        }
        
        #editor {
            flex: 1;
            width: 100%;
            height: 100%;
        }
        
        #editor-fallback {
            flex: 1;
            width: 100%;
            height: 100%;
            background: #1e1e1e;
            color: #e0e0e0;
            border: none;
            padding: 15px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            resize: none;
            outline: none;
        }
        
        button {
            background: #4a4a4a;
            color: #e0e0e0;
            border: 1px solid #5a5a5a;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        button:hover {
            background: #5a5a5a;
        }
        
        button:active {
            background: #3a3a3a;
        }
        
        button.primary {
            background: #0066cc;
            border-color: #0077dd;
        }
        
        button.primary:hover {
            background: #0077dd;
        }
        
        #status {
            flex: 1;
            padding: 8px 15px;
            background: #2a2a2a;
            border-radius: 4px;
            font-size: 13px;
            color: #a0a0a0;
        }
        
        #status.error {
            color: #ff6b6b;
        }
        
        #status.success {
            color: #51cf66;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #888;
        }
        
        .spinner {
            border: 3px solid #333;
            border-top: 3px solid #0066cc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        
        #version-history-panel {
            position: fixed;
            top: 0;
            left: 0;
            width: 350px;
            height: 100vh;
            background: #1e1e1e;
            border-right: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
            z-index: 998;
            transform: translateX(-100%);
            transition: transform 0.3s ease;
            box-shadow: 2px 0 8px rgba(0, 0, 0, 0.3);
        }
        
        #version-history-panel.visible {
            transform: translateX(0);
        }
        
        #version-history-header {
            background: #2a2a2a;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #3a3a3a;
        }
        
        #version-history-header h3 {
            margin: 0;
            font-size: 16px;
            color: #e0e0e0;
        }
        
        #version-history-close {
            background: transparent;
            border: none;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 18px;
            padding: 0 10px;
        }
        
        #version-history-list {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }
        
        .version-item {
            padding: 12px;
            margin-bottom: 8px;
            background: #2a2a2a;
            border: 1px solid #3a3a3a;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .version-item:hover {
            background: #3a3a3a;
        }
        
        .version-item.current {
            border-color: #0066cc;
            background: #2a3a4a;
        }
        
        .version-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }
        
        .version-item-time {
            font-size: 12px;
            color: #888;
        }
        
        .version-item-preview {
            font-size: 11px;
            color: #a0a0a0;
            font-family: 'Courier New', monospace;
            white-space: pre-wrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-height: 40px;
            margin-top: 4px;
        }
        
        .version-item-actions {
            display: flex;
            gap: 8px;
            margin-top: 8px;
        }
        
        .version-item-actions button {
            padding: 4px 12px;
            font-size: 12px;
        }
        
        #version-history-toggle {
            font-size: 14px;
            padding: 8px 16px;
        }
    </style>
</head>
<body>
        <div id="container">
        <div id="version-history-panel">
            <div id="version-history-header">
                <h3>Version History</h3>
                <button id="version-history-close">Ã—</button>
            </div>
            <div id="version-history-list"></div>
        </div>
        
        <div id="library-panel">
            <div id="library-header">
                <h3>Library</h3>
                <button id="library-close">Ã—</button>
            </div>
            <div id="library-list"></div>
        </div>
        
        <div id="canvas-container">
            <div class="loading" id="loading">
                <div class="spinner"></div>
                <div>Loading DingCAD...</div>
            </div>
            <canvas id="canvas"></canvas>
        </div>
        
        <div id="toolbar">
            <div id="toolbar-buttons">
                <button id="edit-btn">Edit Code</button>
                <button id="reset-btn">Reset View</button>
                <div id="status">Ready</div>
                <button id="library-toggle" title="Library">Library</button>
            </div>
            <div id="code-editor-panel" class="minimized" style="display: flex;">
                <div id="editor-header">
                    <h3 id="editor-title">Code Editor</h3>
                    <button id="editor-close" title="Toggle expand/minimize">â–¼</button>
                </div>
                <div id="editor-content">
                    <div id="editor"></div>
                    <textarea id="editor-fallback" style="display: none;"></textarea>
                </div>
            </div>
        </div>
    </div>
    
    <script type="module">
        // Module loader and initialization
        let Module = null;
        let isInitialized = false;
        
        // Initialize Emscripten module
        async function initModule() {
            try {
                // Log build version for tracking updates
                const buildTimestamp = new Date().toISOString();
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                console.log('ðŸš€ DingCAD Web Viewer');
                console.log(`ðŸ“¦ Build: ${buildTimestamp}`);
                console.log(`ðŸ”„ Refresh: ${window.location.href}?t=${Date.now()}`);
                console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
                
                // Get canvas element before module creation (needed for GLFW initialization)
                const canvas = document.getElementById('canvas');
                
                // Load the WebAssembly module
                // With EXPORT_ES6=1 and EXPORT_NAME='createDingCADModule', the module exports:
                // - default export: the factory function (preferred)
                // - named export 'createDingCADModule': the factory function (fallback)
                const moduleFactory = await import('./dingcad_viewer.js');
                const createModule = moduleFactory.default || moduleFactory.createDingCADModule;
                if (typeof createModule !== 'function') {
                    const availableExports = Object.keys(moduleFactory).join(', ') || 'none';
                    throw new Error(
                        `Module factory function not found. ` +
                        `Expected default or createDingCADModule export. ` +
                        `Available exports: ${availableExports}`
                    );
                }
                
                // Track if main has been called to prevent double initialization
                let mainCalled = false;
                
                // Create module with configuration (canvas must be set before GLFW init)
                Module = await createModule({
                    canvas: canvas,
                    onRuntimeInitialized: function() {
                        // Runtime is ready, now call main (only once)
                        if (mainCalled) {
                            console.log('Main already called, skipping');
                            return;
                        }
                        
                        // 'this' refers to the module instance in Emscripten callbacks
                        const moduleInst = this || Module;
                        
                        // Main runs automatically with INVOKE_RUN=1
                        // Just hide loading and mark as initialized
                        mainCalled = true;
                        document.getElementById('loading').style.display = 'none';
                        isInitialized = true;
                        
                        // Log successful initialization
                        console.log('âœ… DingCAD initialized successfully');
                        console.log(`ðŸ“… Initialized at: ${new Date().toISOString()}`);
                        
                        updateStatus('Ready', 'success');
                        
                        // Set up canvas resize handler
                        setupCanvasResize();
                        
                        // Force immediate resize after module is ready
                        setTimeout(() => {
                            resizeCanvas();
                        }, 100);
                        
                        // Check if we should auto-load the last library item
                        moduleInitialized = true;
                        checkAndAutoLoad();
                    },
                    print: function(text) {
                        console.log(text);
                    },
                    printErr: function(text) {
                        console.error(text);
                    }
                });
                
                // If runtime already initialized (synchronous case), call main immediately
                // But only if onRuntimeInitialized hasn't been called yet
                if (Module && Module.ready && !mainCalled) {
                    try {
                        let callMainFn = null;
                        if (typeof Module.callMain === 'function') {
                            callMainFn = () => Module.callMain();
                        } else if (typeof Module._main === 'function') {
                            callMainFn = () => Module._main();
                        }
                        
                        if (callMainFn) {
                            mainCalled = true;
                            callMainFn();
                    document.getElementById('loading').style.display = 'none';
                    isInitialized = true;
                    updateStatus('Ready', 'success');
                    // Set up canvas resize handler
                    setupCanvasResize();
                    // Force immediate resize after module is ready
                    setTimeout(() => {
                        resizeCanvas();
                    }, 100);
                        } else {
                            console.warn('callMain not available synchronously, waiting for onRuntimeInitialized');
                        }
                    } catch (err) {
                        console.error('Error calling main (sync):', err);
                        updateStatus('Error: ' + err.message, 'error');
                        mainCalled = false; // Allow retry
                    }
                }
            } catch (error) {
                console.error('âŒ Failed to initialize:', error);
                console.error(`ðŸ“… Error at: ${new Date().toISOString()}`);
                updateStatus('Failed to load: ' + error.message, 'error');
            }
        }
        
        function updateStatus(message, type = '') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = type;
        }
        
        // Canvas resize handler - ensures canvas internal resolution matches display size
        function resizeCanvas() {
            const canvas = document.getElementById('canvas');
            const container = document.getElementById('canvas-container');
            if (!canvas || !container) return;
            
            // Get the actual pixel dimensions of the container
            const rect = container.getBoundingClientRect();
            const width = Math.floor(rect.width);
            const height = Math.floor(rect.height);
            
            // Only resize if dimensions actually changed
            if (canvas.width !== width || canvas.height !== height) {
                // Update canvas internal resolution to match display size
                canvas.width = width;
                canvas.height = height;
                
                // Ensure canvas is positioned at top-left of container
                canvas.style.top = '0';
                canvas.style.left = '0';
                canvas.style.width = width + 'px';
                canvas.style.height = height + 'px';
                
                // Canvas resize is handled automatically by Emscripten/raylib
                // The canvas width/height attributes are sufficient for proper rendering
                // Emscripten will automatically update GetScreenWidth/GetScreenHeight
                
                console.log(`ðŸ–¼ï¸ Canvas resized to ${width}x${height}`);
            }
        }
        
        // Set up resize observer and window resize listener
        let canvasResizeSetup = false;
        let resizeTimeout = null;
        function setupCanvasResize() {
            if (canvasResizeSetup) return; // Already set up
            const container = document.getElementById('canvas-container');
            if (!container) return;
            
            // Initial resize
            resizeCanvas();
            
            // Use ResizeObserver for better performance and accuracy
            // Debounce resize events to prevent excessive calls during panel animations
            const resizeObserver = new ResizeObserver(() => {
                // Clear any pending resize
                if (resizeTimeout) {
                    clearTimeout(resizeTimeout);
                }
                // Debounce resize to avoid triggering during panel animations
                resizeTimeout = setTimeout(() => {
                    resizeCanvas();
                    resizeTimeout = null;
                }, 150); // 150ms debounce
            });
            resizeObserver.observe(container);
            
            // Fallback to window resize for older browsers
            window.addEventListener('resize', () => {
                // Clear any pending resize
                if (resizeTimeout) {
                    clearTimeout(resizeTimeout);
                }
                // Debounce resize
                resizeTimeout = setTimeout(() => {
                    resizeCanvas();
                    resizeTimeout = null;
                }, 150);
            });
            
            canvasResizeSetup = true;
            console.log('âœ… Canvas resize handler initialized');
        }
        
        // Monaco Editor setup with fallback
        let editor = null;
        let useFallbackEditor = false;
        let codeEditorVisible = false; // Start minimized
        let currentFileName = null;
        let saveTimeout = null;
        
        // Version History System
        const VERSION_HISTORY_KEY = 'dingcad_version_history';
        const MAX_VERSIONS = 50; // Maximum number of versions to keep
        let versionHistory = [];
        let currentVersionId = null;
        let versionHistoryPanelVisible = false;
        let isRestoringVersion = false;
        
        // Load version history from localStorage
        function loadVersionHistory() {
            try {
                const stored = localStorage.getItem(VERSION_HISTORY_KEY);
                if (stored) {
                    versionHistory = JSON.parse(stored);
                    console.log(`ðŸ“œ Loaded ${versionHistory.length} versions from history`);
                } else {
                    versionHistory = [];
                }
            } catch (e) {
                console.warn('âš ï¸ Failed to load version history:', e);
                versionHistory = [];
            }
        }
        
        // Save version history to localStorage
        function saveVersionHistory() {
            try {
                localStorage.setItem(VERSION_HISTORY_KEY, JSON.stringify(versionHistory));
            } catch (e) {
                console.warn('âš ï¸ Failed to save version history:', e);
                // If storage is full, try to remove old versions
                if (e.name === 'QuotaExceededError') {
                    // Keep only the most recent 25 versions
                    versionHistory = versionHistory.slice(-25);
                    try {
                        localStorage.setItem(VERSION_HISTORY_KEY, JSON.stringify(versionHistory));
                    } catch (e2) {
                        console.error('âŒ Still failed to save after cleanup:', e2);
                    }
                }
            }
        }
        
        // Save a new version to history
        function saveVersion(code, filename) {
            if (isRestoringVersion) {
                return; // Don't save when restoring
            }
            
            const now = new Date();
            const version = {
                id: Date.now().toString() + Math.random().toString(36).substr(2, 9),
                timestamp: now.getTime(),
                date: now.toISOString(),
                code: code,
                filename: filename || currentFileName || 'Untitled',
                preview: code.substring(0, 100).replace(/\n/g, ' ').trim()
            };
            
            // Check if this is the same as the last version (avoid duplicates)
            if (versionHistory.length > 0) {
                const lastVersion = versionHistory[versionHistory.length - 1];
                if (lastVersion.code === code && lastVersion.filename === version.filename) {
                    // Same code, just update the current version ID
                    currentVersionId = lastVersion.id;
                    return;
                }
            }
            
            versionHistory.push(version);
            currentVersionId = version.id;
            
            // Limit history size
            if (versionHistory.length > MAX_VERSIONS) {
                versionHistory = versionHistory.slice(-MAX_VERSIONS);
            }
            
            saveVersionHistory();
            updateVersionHistoryUI();
            console.log(`ðŸ’¾ Saved version: ${version.filename} (${new Date(version.timestamp).toLocaleTimeString()})`);
        }
        
        // Revert to a specific version
        function revertToVersion(versionId) {
            const version = versionHistory.find(v => v.id === versionId);
            if (!version) {
                console.error('âŒ Version not found:', versionId);
                return;
            }
            
            console.log(`â†©ï¸ Reverting to version: ${version.filename} (${new Date(version.timestamp).toLocaleString()})`);
            
            isRestoringVersion = true;
            if (editor) {
                editor.setValue(version.code);
                if (!useFallbackEditor) {
                    // Force Monaco to update
                    setTimeout(() => {
                        editor.layout();
                        const model = editor.getModel();
                        if (model) {
                            editor.setPosition({ lineNumber: 1, column: 1 });
                        }
                    }, 50);
                }
            }
            
            // Update filename if it changed
            if (version.filename !== currentFileName) {
                updateEditorTitle(version.filename);
            }
            
            currentVersionId = versionId;
            updateVersionHistoryUI();
            
            // Execute the code after a short delay
            setTimeout(() => {
                isRestoringVersion = false;
                executeCode();
            }, 100);
        }
        
        // Update the version history UI
        function updateVersionHistoryUI() {
            const list = document.getElementById('version-history-list');
            if (!list) return;
            
            list.innerHTML = '';
            
            if (versionHistory.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No version history yet</div>';
                return;
            }
            
            // Show versions in reverse chronological order (newest first)
            const sortedVersions = [...versionHistory].reverse();
            
            sortedVersions.forEach(version => {
                const item = document.createElement('div');
                item.className = 'version-item' + (version.id === currentVersionId ? ' current' : '');
                
                const date = new Date(version.timestamp);
                const timeStr = date.toLocaleString();
                const relativeTime = getRelativeTime(date);
                
                item.innerHTML = `
                    <div class="version-item-header">
                        <strong style="color: #e0e0e0;">${version.filename}</strong>
                        <span class="version-item-time">${relativeTime}</span>
                    </div>
                    <div class="version-item-preview">${escapeHtml(version.preview)}${version.code.length > 100 ? '...' : ''}</div>
                    <div class="version-item-actions">
                        <button class="primary" onclick="window.revertToVersion('${version.id}')">Revert</button>
                        <button onclick="window.viewVersion('${version.id}')">View</button>
                    </div>
                `;
                
                list.appendChild(item);
            });
        }
        
        // Helper function to get relative time
        function getRelativeTime(date) {
            const now = new Date();
            const diffMs = now.getTime() - date.getTime();
            const diffSecs = Math.floor(diffMs / 1000);
            const diffMins = Math.floor(diffSecs / 60);
            const diffHours = Math.floor(diffMins / 60);
            const diffDays = Math.floor(diffHours / 24);
            
            if (diffSecs < 60) return 'just now';
            if (diffMins < 60) return `${diffMins}m ago`;
            if (diffHours < 24) return `${diffHours}h ago`;
            if (diffDays < 7) return `${diffDays}d ago`;
            return date.toLocaleDateString();
        }
        
        // Helper function to escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        // Make functions available globally for onclick handlers
        window.revertToVersion = revertToVersion;
        window.viewVersion = function(versionId) {
            const version = versionHistory.find(v => v.id === versionId);
            if (!version) return;
            
            // Show version in a modal or alert (simple version)
            const codePreview = version.code.substring(0, 500) + (version.code.length > 500 ? '\n...' : '');
            alert(`Version from ${new Date(version.timestamp).toLocaleString()}\n\n${codePreview}`);
        };
        
        // Toggle version history panel
        function toggleVersionHistoryPanel() {
            versionHistoryPanelVisible = !versionHistoryPanelVisible;
            const panel = document.getElementById('version-history-panel');
            if (versionHistoryPanelVisible) {
                panel.classList.add('visible');
                updateVersionHistoryUI();
            } else {
                panel.classList.remove('visible');
            }
        }
        
        // Initialize fallback editor (textarea)
        function initFallbackEditor() {
            console.log('Using fallback textarea editor');
            useFallbackEditor = true;
            const fallbackEditor = document.getElementById('editor-fallback');
            const monacoEditor = document.getElementById('editor');
            fallbackEditor.style.display = 'block';
            monacoEditor.style.display = 'none';
            fallbackEditor.value = '// Code editor - load a library item or write your own scene\n// Example:\n// export const scene = cube({ size: [1, 1, 1], center: true });';
            
            // Set initial title
            updateEditorTitle(null);
            
            // Auto-save and execute on change (with debounce)
            fallbackEditor.addEventListener('input', () => {
                if (saveTimeout) clearTimeout(saveTimeout);
                saveTimeout = setTimeout(() => {
                    const code = fallbackEditor.value;
                    // Only save version and execute if module is ready
                    if (Module && isInitialized && editor) {
                        saveVersion(code, currentFileName);
                        executeCode();
                    }
                }, 1000); // 1 second debounce
            });
            
            editor = {
                getValue: () => fallbackEditor.value,
                setValue: (value) => { fallbackEditor.value = value; },
                layout: () => {} // No-op for fallback
            };
        }
        
        // Initialize editor (Monaco or fallback)
        function initEditor() {
            // Check if Monaco failed to load or if require is not available
            if (window.monacoLoadFailed || typeof require === 'undefined') {
                initFallbackEditor();
            } else {
                // Try to initialize Monaco Editor
                try {
                    require.config({ paths: { vs: 'https://cdn.jsdelivr.net/npm/monaco-editor@0.45.0/min/vs' } });
                    require(['vs/editor/editor.main'], function () {
                        editor = monaco.editor.create(document.getElementById('editor'), {
                            value: '// Code editor - load a library item or write your own scene\n// Example:\n// export const scene = cube({ size: [1, 1, 1], center: true });',
                            language: 'javascript',
                            theme: 'vs-dark',
                            fontSize: 14,
                            minimap: { enabled: false },
                            scrollBeyondLastLine: false,
                            automaticLayout: true,
                            wordWrap: 'on'
                        });
                        
                        // Set initial title when editor loads with default code
                        updateEditorTitle(null);
                        
                        // Auto-save and execute on change (with debounce)
                        editor.onDidChangeModelContent(() => {
                            if (saveTimeout) clearTimeout(saveTimeout);
                            saveTimeout = setTimeout(() => {
                                const code = editor.getValue();
                                // Only save version and execute if module is ready
                                if (Module && isInitialized) {
                                    saveVersion(code, currentFileName);
                                    executeCode();
                                }
                            }, 1000); // 1 second debounce
                        });
                    }, function(error) {
                        console.error('Failed to load Monaco Editor:', error);
                        initFallbackEditor();
                    });
                } catch (error) {
                    console.error('Failed to initialize Monaco Editor:', error);
                    initFallbackEditor();
                }
            }
        }
        
        // Initialize editor after a short delay to allow Monaco loader to fail if needed
        setTimeout(initEditor, 100);
        
        // Code editor panel toggle (minimize/expand)
        function toggleCodeEditorPanel() {
            const panel = document.getElementById('code-editor-panel');
            
            if (panel.classList.contains('minimized')) {
                // Expand
                panel.classList.remove('minimized');
                panel.classList.add('expanded');
                if (editor && !useFallbackEditor) {
                    // Force Monaco to re-render and re-tokenize when expanded
                    setTimeout(() => {
                        editor.layout();
                        // Trigger a content change to force re-tokenization
                        const model = editor.getModel();
                        if (model) {
                            const value = model.getValue();
                            model.setValue('');
                            model.setValue(value);
                        }
                        editor.render();
                    }, 100);
                }
                // Canvas resize will be handled automatically by the debounced ResizeObserver
                // No need to call resizeCanvas() explicitly - this prevents reload during animation
            } else {
                // Minimize
                panel.classList.remove('expanded');
                panel.classList.add('minimized');
                // Canvas resize will be handled automatically by the debounced ResizeObserver
                // No need to call resizeCanvas() explicitly - this prevents reload during animation
            }
        }
        
        document.getElementById('editor-close').addEventListener('click', (e) => {
            e.stopPropagation();
            toggleCodeEditorPanel();
        });
        
        // Also allow clicking header to toggle
        document.getElementById('editor-header').addEventListener('click', () => {
            toggleCodeEditorPanel();
        });
        
        // Function to update editor title with filename
        function updateEditorTitle(filename) {
            const titleElement = document.getElementById('editor-title');
            if (filename) {
                titleElement.textContent = filename;
                currentFileName = filename;
            } else {
                titleElement.textContent = 'Code Editor';
                currentFileName = null;
            }
        }
        
        function executeCode() {
            if (!Module || !editor || !isInitialized) {
                console.warn('âš ï¸ Cannot execute code: Module or editor not ready');
                return;
            }
            
            const code = editor.getValue();
            if (!code || code.trim().length === 0) {
                console.warn('âš ï¸ Cannot execute: empty code');
                return;
            }
            
            // Check if code is only comments (common pattern for placeholder code)
            const codeWithoutComments = code.replace(/\/\/.*$/gm, '').replace(/\/\*[\s\S]*?\*\//g, '').trim();
            if (codeWithoutComments.length === 0) {
                console.warn('âš ï¸ Cannot execute: code contains only comments');
                return;
            }
            
            // Check if code exports a scene
            if (!code.includes('export') && !code.includes('export const scene') && !code.includes('export { scene }')) {
                console.warn('âš ï¸ Code does not appear to export a scene');
                // Don't return - let it try anyway, might be a function that will be wrapped
            }
            
            try {
                console.log('ðŸ“ Executing code...');
                console.log('Code preview:', code.substring(0, 200) + (code.length > 200 ? '...' : ''));
                // Write code to virtual filesystem and load it
                Module.FS.writeFile('/tmp/scene.js', code);
                // Call the C++ function to load the scene
                Module.ccall('loadSceneFromCode', null, ['string'], [code]);
                console.log('âœ… Code execution call completed');
                
                // Poll for status updates with detailed error reporting
                let attempts = 0;
                const maxAttempts = 50; // 5 seconds max wait
                const checkStatus = () => {
                    attempts++;
                    try {
                        const statusMsg = Module.ccall('getStatusMessage', 'string', [], []);
                        console.log(`ðŸ“Š Status check ${attempts}:`, statusMsg);
                        
                        if (statusMsg && statusMsg.includes('Error')) {
                            console.error('âŒ Scene load failed with error:', statusMsg);
                            updateStatus(statusMsg, 'error');
                            return;
                        }
                        
                        if (statusMsg && statusMsg.includes('successfully')) {
                            console.log('âœ… Scene loaded successfully:', statusMsg);
                            updateStatus(statusMsg, 'success');
                            
                            // Restore camera state from URL if it was set (scene loading auto-resets camera)
                            // Camera tracking should already be disabled from parseURLAndRestoreState
                            // Note: Code may execute multiple times, so we restore on every scene load
                            if (pendingCameraStateFromURL) {
                                console.log('ðŸ“· Restoring camera state from URL after scene load:', pendingCameraStateFromURL);
                                
                                // Clear any existing timeout and interval - we'll set new ones
                                if (cameraRestoreTimeout) {
                                    clearTimeout(cameraRestoreTimeout);
                                    cameraRestoreTimeout = null;
                                }
                                if (cameraRestoreInterval) {
                                    clearInterval(cameraRestoreInterval);
                                    cameraRestoreInterval = null;
                                }
                                
                                // Restore IMMEDIATELY to minimize visible flash of default camera
                                setCameraState(pendingCameraStateFromURL);
                                
                                // Also set up a continuous restoration loop to keep it in place
                                // This handles cases where C++ resets the camera multiple times
                                let restoreAttempts = 0;
                                const maxRestoreAttempts = 10; // Restore up to 10 times over 2 seconds
                                cameraRestoreInterval = setInterval(() => {
                                    restoreAttempts++;
                                    if (pendingCameraStateFromURL) {
                                        setCameraState(pendingCameraStateFromURL);
                                    } else {
                                        clearInterval(cameraRestoreInterval);
                                        cameraRestoreInterval = null;
                                    }
                                    
                                    if (restoreAttempts >= maxRestoreAttempts) {
                                        clearInterval(cameraRestoreInterval);
                                        cameraRestoreInterval = null;
                                        
                                        // Set lastCameraState to the desired state to prevent tracking updates
                                        if (pendingCameraStateFromURL) {
                                            lastCameraState = {
                                                yaw: pendingCameraStateFromURL.yaw,
                                                pitch: pendingCameraStateFromURL.pitch,
                                                distance: pendingCameraStateFromURL.distance,
                                                target: {
                                                    x: pendingCameraStateFromURL.target.x,
                                                    y: pendingCameraStateFromURL.target.y,
                                                    z: pendingCameraStateFromURL.target.z
                                                }
                                            };
                                        }
                                        
                                        // Schedule re-enabling tracking and clearing pending state
                                        // Use a longer delay to handle multiple scene loads
                                        // Only clear after we're sure no more scene loads will happen
                                        cameraRestoreTimeout = setTimeout(() => {
                                            cameraTrackingDisabled = false;
                                            console.log('ðŸ“· Re-enabled camera tracking after URL restoration (all scene loads complete)');
                                            // Clear the pending state after all executions are done
                                            pendingCameraStateFromURL = null;
                                            cameraRestoreTimeout = null;
                                        }, 1500); // 1.5 seconds after last restore attempt
                                    }
                                }, 200); // Restore every 200ms
                            }
                            
                            // Try to extract model stats if available from status message
                            // Status messages often contain model info like "X triangles, Y vertices"
                            const statsMatch = statusMsg.match(/(\d+)\s*(?:triangles?|tris?)/i);
                            if (statsMatch) {
                                // Cache model info for currently selected files
                                const selectedFiles = Array.from(selectedLibraryItems)
                                    .map(fileKey => libraryFiles.find(file => getFileKey(file) === fileKey))
                                    .filter(file => file !== undefined);
                                
                                selectedFiles.forEach(file => {
                                    const fileKey = getFileKey(file);
                                    if (!modelInfoCache.has(fileKey)) {
                                        modelInfoCache.set(fileKey, {
                                            status: statusMsg,
                                            hasStats: true
                                        });
                                    }
                                });
                                
                                // Update library list to show new info
                                populateLibraryList();
                            }
                            return;
                        }
                        
                        // If still processing and haven't exceeded max attempts, check again
                        if (attempts < maxAttempts) {
                            setTimeout(checkStatus, 100);
                        } else {
                            // Timeout - check final status
                            const finalStatus = Module.ccall('getStatusMessage', 'string', [], []);
                            if (finalStatus && finalStatus.includes('Error')) {
                                console.error('âŒ Scene load failed (timeout):', finalStatus);
                                updateStatus(finalStatus, 'error');
                            } else {
                                console.warn('âš ï¸ Status check timeout, final status:', finalStatus || 'unknown');
                                updateStatus(finalStatus || 'Status unknown - check console for details', 'warning');
                            }
                        }
                    } catch (error) {
                        console.error('âŒ Error checking status:', error);
                        updateStatus('Error checking status: ' + error.message, 'error');
                    }
                };
                
                // Start checking status after a short delay
                setTimeout(checkStatus, 100);
                } catch (error) {
                console.error('âŒ Code execution error:', error);
                console.error('Error stack:', error.stack);
                    updateStatus('Error: ' + error.message, 'error');
            }
        }
        
        
        document.getElementById('edit-btn').addEventListener('click', () => {
            const panel = document.getElementById('code-editor-panel');
            if (panel.classList.contains('hidden')) {
                panel.classList.remove('hidden');
                panel.classList.add('minimized');
            } else {
                // Toggle expand/minimize
                toggleCodeEditorPanel();
            }
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            if (Module && Module.ccall) {
                Module.ccall('resetCamera', null, [], []);
                // Update URL after reset
                setTimeout(() => {
                    const cameraState = getCameraState();
                    if (cameraState) {
                        // Get currently selected items to preserve them
                        const selectedFiles = Array.from(selectedLibraryItems)
                            .map(fileKey => libraryFiles.find(file => getFileKey(file) === fileKey))
                            .filter(file => file !== undefined);
                        updateURL(selectedFiles.length > 0 ? selectedFiles : null, cameraState);
                    }
                }, 100);
            }
        });
        
        // Library panel functionality - dynamically loaded from manifest
        let libraryFiles = [];
        let libraryPanelVisible = false;
        let selectedLibraryItems = new Set(); // Track selected library items by fileKey
        let modelInfoCache = new Map(); // Cache model info (vertices, triangles) per file
        let pendingCameraStateFromURL = null; // Store camera state from URL to restore after scene loads
        let cameraTrackingDisabled = false; // Flag to disable camera tracking during URL restoration
        let cameraRestoreTimeout = null; // Timeout to delay clearing pendingCameraStateFromURL
        let cameraRestoreInterval = null; // Interval for continuous camera restoration
        
        // Load library manifest dynamically
        async function loadLibraryManifest() {
            try {
                console.log('ðŸ“š Loading library manifest...');
                const response = await fetch('./library-manifest.json');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                const manifest = await response.json();
                libraryFiles = manifest.files || [];
                console.log(`âœ… Loaded ${libraryFiles.length} library files from manifest`);
                // Repopulate the library list with new data
                populateLibraryList();
            } catch (error) {
                console.error('âŒ Failed to load library manifest:', error);
                console.warn('âš ï¸ Falling back to empty library list');
                libraryFiles = [];
                populateLibraryList();
            }
        }
        
        function toggleLibraryPanel() {
            libraryPanelVisible = !libraryPanelVisible;
            const panel = document.getElementById('library-panel');
            if (libraryPanelVisible) {
                panel.classList.add('visible');
            } else {
                panel.classList.remove('visible');
            }
        }
        
        // URL management functions
        function updateURL(libraryItems = null, cameraState = null, preserveParams = true) {
            const url = new URL(window.location);
            
            // If preserveParams is false, clear camera params first (only when setting library items)
            if (!preserveParams && libraryItems !== null) {
                url.searchParams.delete('yaw');
                url.searchParams.delete('pitch');
                url.searchParams.delete('distance');
                url.searchParams.delete('tx');
                url.searchParams.delete('ty');
                url.searchParams.delete('tz');
            }
            
            // Handle library items - always use 'items' parameter (array, can be single or multiple)
            // Only delete/update library items if explicitly provided (libraryItems !== null)
            // When libraryItems is null, preserve existing items from URL
            if (libraryItems !== null) {
                url.searchParams.delete('item'); // Remove old 'item' param for backward compat
                url.searchParams.delete('items');
                
                if (libraryItems.length > 0) {
                    // Sort items alphabetically by fileKey to maintain consistent order
                    const sortedItems = [...libraryItems].sort((a, b) => {
                        const keyA = a.path || `${a.folder || 'root'}/${a.name}`;
                        const keyB = b.path || `${b.folder || 'root'}/${b.name}`;
                        return keyA.localeCompare(keyB);
                    });
                    
                    // Always use 'items' parameter (comma-separated, sorted a-z)
                    const fileKeys = sortedItems.map(item => 
                        item.path || `${item.folder || 'root'}/${item.name}`
                    );
                    url.searchParams.set('items', fileKeys.join(','));
                }
            }
            // If libraryItems is null, existing library items in URL are preserved automatically
            
            // Don't update camera params if tracking is disabled (during URL restoration)
            if (cameraState !== null && !cameraTrackingDisabled) {
                if (cameraState.yaw !== undefined) url.searchParams.set('yaw', cameraState.yaw.toFixed(4));
                if (cameraState.pitch !== undefined) url.searchParams.set('pitch', cameraState.pitch.toFixed(4));
                if (cameraState.distance !== undefined) url.searchParams.set('distance', cameraState.distance.toFixed(4));
                if (cameraState.target !== undefined) {
                    url.searchParams.set('tx', cameraState.target.x.toFixed(4));
                    url.searchParams.set('ty', cameraState.target.y.toFixed(4));
                    url.searchParams.set('tz', cameraState.target.z.toFixed(4));
                }
            }
            // If cameraState is null or tracking is disabled, camera params are preserved automatically
            
            // Update URL without page reload
            window.history.replaceState({}, '', url);
        }
        
        // Get file key for a library item
        function getFileKey(file) {
            return file.path || `${file.folder || 'root'}/${file.name}`;
        }
        
        // Cache for camera target buffer to avoid repeated allocations
        let cameraTargetBuffer = null;
        
        function getCameraState() {
            if (!Module || !Module.ccall) return null;
            try {
                const yaw = Module.ccall('getCameraYaw', 'number', [], []);
                const pitch = Module.ccall('getCameraPitch', 'number', [], []);
                const distance = Module.ccall('getCameraDistance', 'number', [], []);
                const target = { x: 0, y: 0, z: 0 };
                
                // Allocate memory for return values (3 floats) - use cached buffer if possible
                let targetPtr = null;
                let usedMalloc = false;
                
                // Try _malloc first (requires explicit freeing)
                if (typeof Module._malloc === 'function' && typeof Module._free === 'function') {
                    try {
                        targetPtr = Module._malloc(12); // 3 floats * 4 bytes
                        usedMalloc = true;
                    } catch (e) {
                        // Fall through to next option
                    }
                }
                
                // Try stackAlloc (doesn't require freeing, but may not be exported)
                if (!targetPtr) {
                    try {
                        // Check if property exists first to avoid abort if not exported
                        if ('stackAlloc' in Module && typeof Module.stackAlloc === 'function') {
                            targetPtr = Module.stackAlloc(12);
                        }
                    } catch (e) {
                        // stackAlloc not available or not exported, continue to next option
                    }
                }
                
                // Try allocate as fallback
                if (!targetPtr && typeof Module.allocate === 'function') {
                    try {
                        targetPtr = Module.allocate(12, 'i8', Module.ALLOC_NORMAL);
                    } catch (e) {
                        // Fall through
                    }
                }
                
                // If no allocation method worked, return with default target values
                if (!targetPtr) {
                    return { yaw, pitch, distance, target };
                }
                
                try {
                    // Call with pointers as arguments
                    Module.ccall('getCameraTarget', null, ['number', 'number', 'number'], 
                        [targetPtr, targetPtr + 4, targetPtr + 8]);
                    
                    // Read values from memory - use getValue if available, otherwise HEAPF32
                    if (typeof Module.getValue === 'function') {
                        target.x = Module.getValue(targetPtr, 'float');
                        target.y = Module.getValue(targetPtr + 4, 'float');
                        target.z = Module.getValue(targetPtr + 8, 'float');
                    } else if (Module.HEAPF32) {
                        // Fallback to HEAPF32
                        target.x = Module.HEAPF32[targetPtr / 4];
                        target.y = Module.HEAPF32[(targetPtr + 4) / 4];
                        target.z = Module.HEAPF32[(targetPtr + 8) / 4];
                    }
                } finally {
                    // Free memory (only if we used malloc, not stackAlloc)
                    if (usedMalloc && typeof Module._free === 'function') {
                        try {
                            Module._free(targetPtr);
                        } catch (e) {
                            // Ignore errors during free
                        }
                    } else if (typeof Module.deallocate === 'function') {
                        try {
                            Module.deallocate(targetPtr);
                        } catch (e) {
                            // Ignore errors during deallocate
                        }
                    }
                    // stackAlloc doesn't need freeing
                }
                
                return { yaw, pitch, distance, target };
            } catch (e) {
                console.warn('âš ï¸ Error getting camera state:', e);
                return null;
            }
        }
        
        function setCameraState(state) {
            if (!Module || !Module.ccall) return false;
            try {
                if (state.yaw !== undefined) Module.ccall('setCameraYaw', null, ['number'], [state.yaw]);
                if (state.pitch !== undefined) Module.ccall('setCameraPitch', null, ['number'], [state.pitch]);
                if (state.distance !== undefined) Module.ccall('setCameraDistance', null, ['number'], [state.distance]);
                if (state.target !== undefined) {
                    Module.ccall('setCameraTarget', null, ['number', 'number', 'number'], 
                        [state.target.x, state.target.y, state.target.z]);
                }
                Module.ccall('updateCameraPosition', null, [], []);
                return true;
            } catch (e) {
                console.warn('âš ï¸ Error setting camera state:', e);
                return false;
            }
        }
        
        // Debounced camera update function
        let cameraUpdateTimeout = null;
        function updateCameraInURL() {
            // Don't update URL if camera tracking is disabled (during URL restoration)
            if (cameraTrackingDisabled) {
                return;
            }
            
            if (cameraUpdateTimeout) clearTimeout(cameraUpdateTimeout);
            cameraUpdateTimeout = setTimeout(() => {
                const cameraState = getCameraState();
                if (cameraState) {
                    updateURL(null, cameraState);
                }
            }, 300); // 300ms debounce
        }
        
        // Toggle library item selection
        function toggleLibraryItem(file) {
            const fileKey = getFileKey(file);
            if (selectedLibraryItems.has(fileKey)) {
                selectedLibraryItems.delete(fileKey);
            } else {
                selectedLibraryItems.add(fileKey);
            }
            updateLibraryUI();
            loadSelectedLibraryItems();
        }
        
        // Load all selected library items and combine them
        function loadSelectedLibraryItems(openPanel = false) {
            if (selectedLibraryItems.size === 0) {
                // No items selected - clear the scene
                if (editor) {
                    editor.setValue('// No library items selected\n// Select items from the library to load them');
                    updateEditorTitle(null);
                    if (Module && isInitialized) {
                        executeCode();
                    }
                }
                // Update URL to remove items
                const currentCameraState = getCameraState();
                updateURL([], currentCameraState, true);
                return;
            }
            
            // Get selected files
            const selectedFiles = Array.from(selectedLibraryItems)
                .map(fileKey => libraryFiles.find(file => getFileKey(file) === fileKey))
                .filter(file => file !== undefined);
            
            // Update URL with selected items (preserve existing camera params) - do this immediately
            // so the URL reflects the current selection even if loading fails
            // BUT: If we have pending camera state from URL, don't update camera params - preserve them
            if (pendingCameraStateFromURL) {
                // Preserve original camera params from URL, don't get current state
                updateURL(selectedFiles.length > 0 ? selectedFiles : [], null, true);
            } else {
                const currentCameraState = getCameraState();
                updateURL(selectedFiles.length > 0 ? selectedFiles : [], currentCameraState, true);
            }
            
            if (selectedFiles.length === 0) {
                console.warn('âš ï¸ No valid files found for selected items');
                // Clear the canvas if no items are selected
                if (editor) {
                    editor.setValue('// No library items selected\n// Select items from the library to load them');
                    updateEditorTitle(null);
                    if (Module && isInitialized) {
                        executeCode();
                    }
                }
                return;
            }
            
            console.log(`ðŸ“š Loading ${selectedFiles.length} library file(s): ${selectedFiles.map(f => f.name).join(', ')}`);
            
            // Store selected items in localStorage
            try {
                const fileKeys = selectedFiles.map(f => getFileKey(f));
                localStorage.setItem('dingcad_last_library_items', JSON.stringify(fileKeys));
            } catch (e) {
                console.warn('âš ï¸ Could not save to localStorage:', e);
            }
            
            // Load all files in parallel
            Promise.all(selectedFiles.map(file => 
            fetch(file.path)
                .then(r => {
                    if (!r.ok) {
                        throw new Error(`HTTP ${r.status}: ${r.statusText}`);
                    }
                    return r.text();
                })
                    .then(code => ({ file, code }))
            )).then(fileData => {
                console.log(`âœ… Loaded ${fileData.length} file(s)`);
                
                // Process each file's code
                const processedCodes = fileData.map(({ file, code }) => {
                    let finalCode = code;
                    
                    // Check if the file exports scene directly
                    if (code.includes('export const scene')) {
                        console.log(`  â†’ ${file.name} exports scene directly`);
                        return finalCode;
                    }
                    
                    // File exports functions - need to handle default export
                    console.log(`  â†’ ${file.name} exports functions, checking for default export...`);
                        
                        // Check if there's already a default export
                        if (code.includes('export default')) {
                        console.log(`  â†’ ${file.name} has default export`);
                        return finalCode;
                    }
                    
                            // No default export, need to create one from named export
                            let functionName = null;
                            
                            // Try to find exported function names
                            const exportFuncMatch = code.match(/export\s+function\s+(\w+)/);
                            if (exportFuncMatch) {
                                functionName = exportFuncMatch[1];
                                console.log(`  â†’ Found named export function: ${functionName}`);
                            }
                            
                            // Fallback to filename-based detection
                            if (!functionName) {
                                if (file.name.includes('xiao')) {
                                    functionName = 'buildXiaoEsp32C3';
                                } else if (file.name.includes('DTSPCB')) {
                                    functionName = 'buildDTSPCB';
                                } else if (file.name.includes('radio')) {
                                    functionName = 'buildRadioEnclosure';
                                } else if (file.name.includes('ifItFitsIsits')) {
                                    functionName = 'ifItFitsIsitsBox';
                                } else {
                                    functionName = 'buildDTSPCB'; // default fallback
                                }
                                console.log(`  â†’ Using filename-based function name: ${functionName}`);
                            }
                            
                            // Create default export that calls the function
                            finalCode = code + '\n\n// Auto-generated: create default export that calls the function\n' +
                                `export default ${functionName};`;
                            
                    return finalCode;
                });
                
                // Combine all codes into a single module
                let combinedCode = '';
                
                if (processedCodes.length === 1) {
                    // Single file - use as-is
                    combinedCode = processedCodes[0];
                } else {
                    // Multiple files - combine them
                    // We'll rename scenes to avoid conflicts and combine them at the end
                    const sceneNames = [];
                    
                    processedCodes.forEach((code, index) => {
                        const file = fileData[index].file;
                        const sceneName = `scene${index}`;
                        
                        // Check if code exports a scene directly
                        if (code.includes('export const scene')) {
                            // Rename the scene export to avoid conflicts
                            // Replace all occurrences of 'export const scene' with 'const sceneName'
                            const renamedCode = code.replace(/export\s+const\s+scene\b/g, `const ${sceneName}`);
                            combinedCode += `// ====== ${file.name} ======\n${renamedCode}\n\n`;
                            sceneNames.push(sceneName);
                        } else if (code.includes('export default')) {
                            // Extract default export function name
                            const funcMatch = code.match(/export\s+default\s+(\w+)\s*;?/);
                            if (funcMatch) {
                                const funcName = funcMatch[1];
                                // Remove the export default line and call the function
                                const modifiedCode = code.replace(/export\s+default\s+\w+\s*;?\s*/g, '');
                                combinedCode += `// ====== ${file.name} ======\n${modifiedCode}\nconst ${sceneName} = ${funcName}();\n\n`;
                                sceneNames.push(sceneName);
                            } else {
                                // Default export might be inline - try to handle it
                                const modifiedCode = code.replace(/export\s+default\s*/, `const ${sceneName} = `);
                                combinedCode += `// ====== ${file.name} ======\n${modifiedCode}\n\n`;
                                sceneNames.push(sceneName);
                            }
                        } else {
                            // No export found - use code as-is
                            combinedCode += `// ====== ${file.name} ======\n${code}\n\n`;
                            // Try to find if there's a scene variable defined
                            const sceneMatch = code.match(/(?:const|let|var)\s+scene\s*=/);
                            if (sceneMatch) {
                                // There's a scene variable - rename it
                                const renamedCode = code.replace(/(?:const|let|var)\s+scene\b/g, `const ${sceneName}`);
                                // Replace the last occurrence in combinedCode
                                const lastIndex = combinedCode.lastIndexOf(`// ====== ${file.name} ======`);
                                if (lastIndex !== -1) {
                                    const before = combinedCode.substring(0, lastIndex);
                                    const after = combinedCode.substring(lastIndex);
                                    combinedCode = before + after.replace(code, renamedCode);
                                }
                                sceneNames.push(sceneName);
                            } else {
                                // Assume the code creates a scene somehow - use a fallback
                                sceneNames.push(sceneName);
                            }
                        }
                    });
                    
                    // Combine all scenes using union (built-in function)
                    if (sceneNames.length > 0) {
                        combinedCode += `\n// ====== Combined Scene ======\n`;
                        if (sceneNames.length === 1) {
                            combinedCode += `export const scene = ${sceneNames[0]};\n`;
                        } else {
                            // Use union to combine multiple scenes
                            combinedCode += `export const scene = union(${sceneNames.join(', ')});\n`;
                        }
                    } else {
                        // Fallback: just export the first scene if no scenes found
                        combinedCode += `\nexport const scene = scene0;\n`;
        }
                    }
        
                    if (editor) {
                    editor.setValue(combinedCode);
                    console.log('  â†’ Combined code loaded into editor');
                    }
                
                // Update editor title
                const title = selectedFiles.length === 1 
                    ? selectedFiles[0].name 
                    : `${selectedFiles.length} items selected`;
                updateEditorTitle(title);
                
                // Save initial version
                    if (editor) {
                        const code = editor.getValue();
                    saveVersion(code, title);
                    }
                
                // Ensure editor panel is visible
                    const panel = document.getElementById('code-editor-panel');
                    panel.classList.remove('hidden');
                    if (!panel.classList.contains('expanded')) {
                        panel.classList.remove('expanded');
                        panel.classList.add('minimized');
                    }
                
                    if (editor && !useFallbackEditor) {
                        setTimeout(() => {
                            editor.layout();
                            const model = editor.getModel();
                            if (model) {
                                const value = model.getValue();
                                model.setValue('');
                                model.setValue(value);
                            }
                            editor.render();
                        }, 100);
                    }
                
                // Execute code
                    setTimeout(() => {
                        // If we have pending camera state, set it immediately before executing
                        // This prevents the default camera from being visible
                        if (pendingCameraStateFromURL) {
                            setCameraState(pendingCameraStateFromURL);
                            console.log('ðŸ“· Pre-restored camera before code execution');
                        }
                        
                        if (!Module || !isInitialized) {
                            console.warn('âš ï¸ Module not ready yet, waiting...');
                            let attempts = 0;
                            const checkReady = setInterval(() => {
                                attempts++;
                                if (Module && isInitialized) {
                                    clearInterval(checkReady);
                                    // Restore camera again right before executing
                                    if (pendingCameraStateFromURL) {
                                        setCameraState(pendingCameraStateFromURL);
                                    }
                                    executeCode();
                            } else if (attempts > 20) {
                                    clearInterval(checkReady);
                                    updateStatus('Error: Module initialization timeout', 'error');
                                    console.error('âŒ Module failed to initialize after timeout');
                                }
                            }, 100);
                        } else {
                            executeCode();
                        }
                    }, 50);
                
                // Only open library panel if requested
                    if (openPanel) {
                        toggleLibraryPanel();
                    }
            }).catch(err => {
                const errorMsg = `Error loading library files: ${err.message}`;
                    console.error('âŒ Library load error:', err);
                    updateStatus(errorMsg, 'error');
                });
        }
        
        // Legacy function for single file loading (backward compatibility)
        function loadLibraryFile(file, openPanel = true) {
            const fileKey = getFileKey(file);
            // Clear all selections and select only this file
            selectedLibraryItems.clear();
            selectedLibraryItems.add(fileKey);
            updateLibraryUI();
            loadSelectedLibraryItems(openPanel);
        }
        
        // Update library UI to reflect selected items
        function updateLibraryUI() {
            // Update selected state in the library list
            const items = document.querySelectorAll('.library-item');
            items.forEach(item => {
                const fileKey = item.dataset.fileKey;
                if (fileKey) {
                    if (selectedLibraryItems.has(fileKey)) {
                        item.classList.add('selected');
                    } else {
                        item.classList.remove('selected');
                    }
                }
            });
        }
        
        function populateLibraryList() {
            const list = document.getElementById('library-list');
            if (!list) {
                console.error('âŒ Library list element not found');
                return;
            }
            
            list.innerHTML = '';
            
            if (!libraryFiles || libraryFiles.length === 0) {
                list.innerHTML = '<div style="padding: 20px; text-align: center; color: #888;">No library files found</div>';
                console.warn('âš ï¸ No library files to display');
                return;
            }
            
            console.log(`ðŸ“š Populating library list with ${libraryFiles.length} files`);
            
            // Group files by folder
            const grouped = {};
            libraryFiles.forEach(file => {
                const folder = file.folder || 'root';
                if (!grouped[folder]) {
                    grouped[folder] = [];
                }
                grouped[folder].push(file);
            });
            
            // Sort folders (root first, then alphabetically)
            const folders = Object.keys(grouped).sort((a, b) => {
                if (a === 'root') return -1;
                if (b === 'root') return 1;
                return a.localeCompare(b);
            });
            
            // Render grouped files
            folders.forEach(folder => {
                const files = grouped[folder];
                
                // Add folder header if not root
                if (folder !== 'root') {
                    const folderHeader = document.createElement('div');
                    folderHeader.className = 'library-folder-header';
                    folderHeader.textContent = folder + '/';
                    list.appendChild(folderHeader);
                }
                
                // Add files in this folder
                files.forEach(file => {
                    const fileKey = getFileKey(file);
                    const item = document.createElement('div');
                    item.className = 'library-item';
                    item.dataset.fileKey = fileKey;
                    
                    const isSelected = selectedLibraryItems.has(fileKey);
                    
                    // Get model info for subtitle - prefer cached info, then folder, then fallback
                    let subtitleText = '';
                    const cachedInfo = modelInfoCache.get(fileKey);
                    
                    if (cachedInfo && cachedInfo.status) {
                        // Extract useful info from status message
                        const status = cachedInfo.status;
                        // Try to extract triangle/vertex counts
                        const triMatch = status.match(/(\d+)\s*(?:triangles?|tris?)/i);
                        const vertMatch = status.match(/(\d+)\s*vertices?/i);
                        
                        if (triMatch && vertMatch) {
                            subtitleText = `${triMatch[1]} triangles, ${vertMatch[1]} vertices`;
                        } else if (triMatch) {
                            subtitleText = `${triMatch[1]} triangles`;
                        } else if (vertMatch) {
                            subtitleText = `${vertMatch[1]} vertices`;
                        } else {
                            // Use folder name or other helpful info
                            subtitleText = file.folder ? `${file.folder} library` : 'Model';
                        }
                    } else {
                        // No cached info - show folder name or function category
                        if (file.folder && file.folder !== 'root') {
                            subtitleText = `${file.folder} library`;
                        } else {
                            // Try to infer from filename what type of model it is
                            const name = file.name.toLowerCase();
                            if (name.includes('pcb') || name.includes('board')) {
                                subtitleText = 'PCB model';
                            } else if (name.includes('enclosure') || name.includes('case')) {
                                subtitleText = 'Enclosure';
                            } else if (name.includes('xiao') || name.includes('esp32')) {
                                subtitleText = 'ESP32 module';
                            } else {
                                subtitleText = '3D model';
                            }
                        }
                    }
                    
                    item.innerHTML = `
                        <div style="flex: 1;">
                        <div class="library-item-name">${file.name}</div>
                        <div class="library-item-desc">${subtitleText || 'No description'}</div>
                        </div>
                    `;
                    
                    // Handle item click (toggle selection)
                    item.addEventListener('click', () => {
                        toggleLibraryItem(file);
                    });
                    
                    if (isSelected) {
                        item.classList.add('selected');
                    }
                    
                    list.appendChild(item);
                });
            });
            
            console.log(`âœ… Library list populated with ${folders.length} folders`);
        }
        
        document.getElementById('library-toggle').addEventListener('click', toggleLibraryPanel);
        document.getElementById('library-close').addEventListener('click', toggleLibraryPanel);
        
        // Version history panel controls (hidden from toolbar, but still accessible via close button)
        document.getElementById('version-history-close').addEventListener('click', toggleVersionHistoryPanel);
        
        // Load version history on startup
        loadVersionHistory();
        
        // Function to parse URL and restore state
        function parseURLAndRestoreState() {
            const urlParams = new URLSearchParams(window.location.search);
            
            // Parse camera state from URL
            const yaw = urlParams.get('yaw');
            const pitch = urlParams.get('pitch');
            const distance = urlParams.get('distance');
            const tx = urlParams.get('tx');
            const ty = urlParams.get('ty');
            const tz = urlParams.get('tz');
            
            if (yaw !== null || pitch !== null || distance !== null || tx !== null || ty !== null || tz !== null) {
                const cameraState = {};
                if (yaw !== null) cameraState.yaw = parseFloat(yaw);
                if (pitch !== null) cameraState.pitch = parseFloat(pitch);
                if (distance !== null) cameraState.distance = parseFloat(distance);
                if (tx !== null || ty !== null || tz !== null) {
                    cameraState.target = {
                        x: tx !== null ? parseFloat(tx) : 0,
                        y: ty !== null ? parseFloat(ty) : 0,
                        z: tz !== null ? parseFloat(tz) : 0
                    };
                }
                
                // Store camera state to restore after scene loads (scene loading auto-resets camera)
                pendingCameraStateFromURL = cameraState;
                console.log('ðŸ“· Stored camera state from URL (will restore after scene loads):', cameraState);
                
                // Disable camera tracking immediately to prevent URL from being overwritten
                // We'll re-enable it after the camera is restored
                cameraTrackingDisabled = true;
                console.log('ðŸ“· Disabled camera tracking to preserve URL camera parameters');
                
                // Try to restore immediately if module is ready and no items are loading
                // But we'll restore it again after scene loads to override the auto-reset
                if (Module && isInitialized) {
                    setCameraState(cameraState);
                    console.log('âœ… Restored camera state from URL (initial):', cameraState);
                } else {
                    // Wait for module to be ready
                    const checkReady = setInterval(() => {
                        if (Module && isInitialized) {
                            clearInterval(checkReady);
                            setCameraState(cameraState);
                            console.log('âœ… Restored camera state from URL (initial):', cameraState);
                        }
                    }, 100);
                    // Timeout after 5 seconds
                    setTimeout(() => clearInterval(checkReady), 5000);
                }
            }
            
            // Parse library items from URL - always use 'items' parameter (migrates old 'item' to 'items')
            const itemsKey = urlParams.get('items');
            const itemKey = urlParams.get('item'); // Backward compatibility: migrate old 'item' to 'items'
            
            let itemsToLoad = [];
            
            // Check if we have items in URL
            if (itemsKey || itemKey) {
                if (!libraryFiles || libraryFiles.length === 0) {
                    console.warn('âš ï¸ URL has items parameter but libraryFiles not loaded yet, will retry...');
                    // Retry after a short delay if libraryFiles aren't ready
                    // Use a flag to track if we're already retrying to avoid duplicate calls
                    if (!window._retryingURLParse) {
                        window._retryingURLParse = true;
                        setTimeout(() => {
                            window._retryingURLParse = false;
                            if (libraryFiles && libraryFiles.length > 0) {
                                console.log('ðŸ”„ Retrying URL parse now that libraryFiles are loaded');
                                parseURLAndRestoreState();
                            } else {
                                console.warn('âš ï¸ LibraryFiles still not loaded after retry');
                            }
                        }, 300);
                    }
                    return false; // Not ready yet, will retry
                }
                
                if (itemsKey) {
                    // Parse items array (comma-separated)
                    // URLSearchParams.get() should decode automatically, but handle edge cases
                    // where the value might be double-encoded or encoded differently
                    let decodedItemsKey = itemsKey;
                    // If the comma is still encoded as %2C, decode it
                    if (decodedItemsKey.includes('%2C')) {
                        decodedItemsKey = decodeURIComponent(decodedItemsKey);
                    }
                    // Also handle if the entire string is encoded
                    try {
                        if (decodedItemsKey.includes('%')) {
                            const testDecode = decodeURIComponent(decodedItemsKey);
                            // Only use if it actually decoded something (not just the same)
                            if (testDecode !== decodedItemsKey) {
                                decodedItemsKey = testDecode;
                            }
                        }
                    } catch (e) {
                        // If decode fails, use original
                        console.warn('âš ï¸ Failed to decode items parameter:', e);
                    }
                    
                    const itemKeys = decodedItemsKey.split(',').map(k => k.trim()).filter(k => k);
                    console.log(`ðŸ” Looking for ${itemKeys.length} item(s) in URL:`, itemKeys);
                    console.log(`ðŸ” Raw itemsKey: "${itemsKey}", Decoded: "${decodedItemsKey}"`);
                    itemsToLoad = itemKeys
                        .map(key => {
                            const file = findMatchingLibraryFile(key, libraryFiles);
                            if (!file) {
                                console.warn(`âš ï¸ Could not find library file matching: ${key}`);
                            }
                            return file;
                        })
                        .filter(file => file !== null && file !== undefined);
                    
                    if (itemsToLoad.length < itemKeys.length) {
                        console.warn(`âš ï¸ Only found ${itemsToLoad.length} of ${itemKeys.length} item(s) from URL`);
                    }
                } else if (itemKey) {
                    // Backward compatibility: migrate old 'item' (singular) to 'items' (plural)
                    console.log(`ðŸ” Looking for item in URL (backward compat):`, itemKey);
                    const matchingFile = findMatchingLibraryFile(itemKey, libraryFiles);
                    if (matchingFile) {
                        itemsToLoad = [matchingFile];
                        // Update URL to use 'items' instead of 'item'
                        const url = new URL(window.location);
                        url.searchParams.delete('item');
                        url.searchParams.set('items', itemKey);
                        window.history.replaceState({}, '', url);
                    } else {
                        console.warn(`âš ï¸ Could not find library file matching: ${itemKey}`);
                    }
                }
            }
            
            if (itemsToLoad.length > 0) {
                console.log(`âœ… Found ${itemsToLoad.length} library item(s) in URL: ${itemsToLoad.map(f => f.name).join(', ')}, loading...`);
                
                // Set selected items immediately
                selectedLibraryItems.clear();
                itemsToLoad.forEach(file => {
                    selectedLibraryItems.add(getFileKey(file));
                });
                updateLibraryUI();
                
                // Load them after module is ready (don't open library panel when loading from URL)
                const loadItems = () => {
                    if (Module && isInitialized && editor) {
                        console.log('ðŸ“š Loading selected library items from URL...');
                        loadSelectedLibraryItems(false);
                        return true; // Loaded successfully
                    } else {
                        const missing = [];
                        if (!Module) missing.push('Module');
                        if (!isInitialized) missing.push('isInitialized');
                        if (!editor) missing.push('editor');
                        console.log(`â³ Waiting for module to be ready before loading items... (missing: ${missing.join(', ')})`);
                        return false; // Not ready yet
                    }
                };
                
                // Try to load immediately if ready, otherwise wait and retry
                if (Module && isInitialized && editor) {
                    // Module is ready, load after a short delay to ensure everything is initialized
                    setTimeout(() => {
                        if (!loadItems()) {
                            // If it still failed, retry with polling
                            const checkReady = setInterval(() => {
                                if (loadItems()) {
                                    clearInterval(checkReady);
                                }
                            }, 200);
                            setTimeout(() => clearInterval(checkReady), 10000); // 10 second timeout
                        }
                    }, 300);
                } else {
                    // Module not ready yet, poll until it's ready
                    const missing = [];
                    if (!Module) missing.push('Module');
                    if (!isInitialized) missing.push('isInitialized');
                    if (!editor) missing.push('editor');
                    console.log(`â³ Module not ready yet, waiting... (missing: ${missing.join(', ')})`);
                    let retryCount = 0;
                    const maxRetries = 50; // 50 * 200ms = 10 seconds
                    const checkReady = setInterval(() => {
                        retryCount++;
                        if (Module && isInitialized && editor) {
                            clearInterval(checkReady);
                            console.log(`âœ… Module ready after ${retryCount} checks, loading items...`);
                            setTimeout(() => {
                                loadItems();
                            }, 300);
                        } else if (retryCount >= maxRetries) {
                            clearInterval(checkReady);
                            console.error('âŒ Module not ready after 10 seconds, giving up');
                        }
                    }, 200);
                }
                return true; // URL items take precedence
            }
            
            // If items were in URL but none matched, return true to prevent falling back to localStorage
            if (itemsKey || itemKey) {
                console.warn('âš ï¸ Items found in URL but none could be matched');
                return true; // URL had items, don't fall back to localStorage
            }
            
            return false; // No URL items, fall back to localStorage
        }
        
        // Helper function to normalize and match file paths
        function findMatchingLibraryFile(searchKey, libraryFiles) {
            if (!searchKey || !libraryFiles || libraryFiles.length === 0) return null;
            
            // Decode and normalize the search key
            const decodedKey = decodeURIComponent(searchKey);
            const normalizedKey = decodedKey.replace(/^\.\//, '').replace(/^\/+/, '');
            
            const matchedFile = libraryFiles.find(file => {
                const fileKey = file.path || `${file.folder || 'root'}/${file.name}`;
                const normalizedFileKey = fileKey.replace(/^\.\//, '').replace(/^\/+/, '');
                
                // Try multiple matching strategies
                const matches = normalizedFileKey === normalizedKey ||
                       fileKey === decodedKey ||
                       file.path === decodedKey ||
                       file.path === normalizedKey ||
                       file.name === decodedKey ||
                       file.name === normalizedKey.split('/').pop() ||
                       `${file.folder || 'root'}/${file.name}` === normalizedKey ||
                       `${file.folder || 'root'}/${file.name}` === decodedKey;
                
                if (matches) {
                    console.log(`âœ… Matched "${searchKey}" -> "${fileKey}" (file: ${file.name})`);
                }
                
                return matches;
            });
            
            if (!matchedFile) {
                // Debug: log first few file keys for comparison
                const sampleKeys = libraryFiles.slice(0, 5).map(f => 
                    f.path || `${f.folder || 'root'}/${f.name}`
                );
                console.log(`ðŸ” No match for "${searchKey}" (decoded: "${decodedKey}", normalized: "${normalizedKey}")`);
                console.log(`   Sample library file keys:`, sampleKeys);
            }
            
            return matchedFile;
        }
        
        // Function to auto-load the last library item(s)
        function autoLoadLastLibraryItem() {
            // Check URL first, if it has items, use that instead
            const urlParams = new URLSearchParams(window.location.search);
            if (urlParams.get('items')) {
                console.log('â„¹ï¸ URL has items parameter, skipping localStorage auto-load');
                return false;
            }
            // Also check for old 'item' parameter for backward compatibility
            if (urlParams.get('item')) {
                console.log('â„¹ï¸ URL has old item parameter, skipping localStorage auto-load');
                return false;
            }
            
            if (!Module || !isInitialized || !libraryFiles || libraryFiles.length === 0) {
                console.log('â³ Waiting for module and library to be ready...');
                return false;
            }
            
            try {
                // Try to load multiple items first (new format)
                const lastItemsJson = localStorage.getItem('dingcad_last_library_items');
                if (lastItemsJson) {
                    try {
                        const lastItemKeys = JSON.parse(lastItemsJson);
                        if (Array.isArray(lastItemKeys) && lastItemKeys.length > 0) {
                            console.log(`ðŸ” Looking for saved library items: ${lastItemKeys.join(', ')}`);
                            
                            const matchingFiles = lastItemKeys
                                .map(key => findMatchingLibraryFile(key, libraryFiles))
                                .filter(file => file !== null && file !== undefined);
                            
                            if (matchingFiles.length > 0) {
                                console.log(`âœ… Found ${matchingFiles.length} saved library item(s), auto-loading...`);
                                
                                // Set selected items
                                selectedLibraryItems.clear();
                                matchingFiles.forEach(file => {
                                    selectedLibraryItems.add(getFileKey(file));
                                });
                                updateLibraryUI();
                                
                                // Load them after a short delay
                                setTimeout(() => {
                                    loadSelectedLibraryItems();
                                }, 500);
                                return true;
                            } else {
                                console.log(`âš ï¸ Saved library items not found in manifest`);
                                localStorage.removeItem('dingcad_last_library_items');
                }
                        }
                    } catch (e) {
                        console.warn('âš ï¸ Error parsing saved library items:', e);
                        localStorage.removeItem('dingcad_last_library_items');
                    }
                }
                
                // Fall back to single item (backward compatibility)
                const lastItemKey = localStorage.getItem('dingcad_last_library_item');
                if (lastItemKey) {
                console.log(`ðŸ” Looking for saved library item: ${lastItemKey}`);
                
                const matchingFile = findMatchingLibraryFile(lastItemKey, libraryFiles);
                
                if (matchingFile) {
                    console.log(`âœ… Found saved library item: ${matchingFile.name}, auto-loading...`);
                        
                        // Set selected item
                        selectedLibraryItems.clear();
                        selectedLibraryItems.add(getFileKey(matchingFile));
                        updateLibraryUI();
                        
                        // Load it after a short delay
                    setTimeout(() => {
                            loadSelectedLibraryItems();
                    }, 500);
                    return true;
                } else {
                    console.log(`âš ï¸ Saved library item not found in manifest: ${lastItemKey}`);
                    localStorage.removeItem('dingcad_last_library_item');
                    return false;
                }
                }
                
                console.log('â„¹ï¸ No saved library items found');
                return false;
            } catch (e) {
                console.warn('âš ï¸ Error auto-loading last library items:', e);
                return false;
            }
        }
        
        // Initialize on page load
        let moduleInitialized = false;
        let manifestLoaded = false;
        
        function checkAndAutoLoad() {
            if (moduleInitialized && manifestLoaded) {
                // Both are ready, try to parse URL and restore state
                // Use a shorter delay since the loading logic handles its own timing
                setTimeout(() => {
                    const urlRestored = parseURLAndRestoreState();
                    // If URL didn't have an item, fall back to localStorage
                    if (!urlRestored) {
                        autoLoadLastLibraryItem();
                    }
                }, 100);
            }
        }
        
        // Track camera changes and update URL
        let lastCameraState = null;
        function trackCameraChanges() {
            if (!Module || !isInitialized) return;
            
            // Don't track camera changes if we're restoring camera from URL
            if (cameraTrackingDisabled) return;
            
            const currentState = getCameraState();
            if (!currentState) return;
            
            // Check if camera state changed significantly
            if (lastCameraState) {
                const threshold = 0.001; // Small threshold to avoid constant updates
                const changed = 
                    Math.abs(currentState.yaw - lastCameraState.yaw) > threshold ||
                    Math.abs(currentState.pitch - lastCameraState.pitch) > threshold ||
                    Math.abs(currentState.distance - lastCameraState.distance) > threshold ||
                    Math.abs(currentState.target.x - lastCameraState.target.x) > threshold ||
                    Math.abs(currentState.target.y - lastCameraState.target.y) > threshold ||
                    Math.abs(currentState.target.z - lastCameraState.target.z) > threshold;
                
                if (changed) {
                    updateCameraInURL();
                }
            }
            
            lastCameraState = currentState;
        }
        
        // Start tracking camera changes after module is initialized
        function startCameraTracking() {
            if (Module && isInitialized) {
                // Poll camera state periodically
                setInterval(trackCameraChanges, 100); // Check every 100ms
            } else {
                setTimeout(startCameraTracking, 100);
            }
        }
        
        loadLibraryManifest().then(() => {
            console.log('âœ… Library manifest loaded');
            manifestLoaded = true;
            checkAndAutoLoad();
        });
        initModule();
        
        // Set up canvas resize handler immediately (before module loads)
        // This ensures initial sizing is correct
        setupCanvasResize();
        
        // Force an immediate resize on page load
        setTimeout(() => {
            resizeCanvas();
        }, 0);
        
        // Start camera tracking after a delay to ensure module is ready
        setTimeout(startCameraTracking, 1000);
    </script>
</body>
</html>

